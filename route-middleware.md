# Middleware

A req/res pair generated by the HTTP server will generally flow through a series of middleware functions which may transform the req/res, branch the flow depending on certain conditions, or terminate the request early \(e.g., in the case of authentication middleware that guards certain routes\).

Funcatron makes it easy to compose stacks of middleware that can be composed together freely using the `stack` method.

Let's make a route group \(see [Routing ](/routing.md)for how to make route groups\) for the API that parses all JSON payloads using the Express body-parser package:

```javascript
const { 
    stack,
    group
} = require("funcatron")

const bodyParser = require("body-parser")() // https://github.com/expressjs/body-parser

const makeBodyParsed = group({
    path: "/api",
    handler: stack(

        // First, parse the incoming JSON body
        ({req, res, next}) => bodyParser(req, res, next),

        // Then ensure a body exists
        ({req, res, next}) => {
            if (!req.body) {
                res.statusCode = 400;
                res.end("Body required")
            } else {
                next()
            }
        }
    )
})

module.exports = makeBodyParsed([
    {
        path: "/register",
        method: "post",
        handler: ({req, res}) => createUser(req.body, err => {
            return (!err) ? res.end("Success!") : res.end("Whoops! Failure")
        })    
    }
])
```



